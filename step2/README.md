# step2 - SQL Injectionを試す
## このステップのゴール
- SQL Injectionの仕組みを理解し、Flagを取得することが出来る。

## 注意
- DBに直接アクセスすると簡単に答えが分かりますが、一旦それはナシでお願いします :bow:

## 手順
### 1. Flaskアプリケーションへのアクセス
`sqli-chall/step2`ディレクトリ内にいることを確認してください。
その後、以下コマンドを実行してアプリケーションを起動してください。

```bash
docker compose up
```

`step2-nginx-1  | /docker-entrypoint.sh: Configuration complete; ready for start up` というログがコンソールに表示されたら、[http://127.0.0.1:31555/](http://127.0.0.1:31555/)にブラウザでアクセスしてください。

その後、名前検索ができることを確認してください。

### 2. データベースとSQL

表示されるSQLについて知りたいかもしれませんが、その前にデータベースについて共有します。データベースとは、[Oracle](https://www.oracle.com/jp/database/what-is-database/)によると、次のように定義されています。

> データベースとは、構造化した情報またはデータの組織的な集合であり、通常はコンピューター・システムに電子的に格納されています。データベースは通常、データベース管理システム（DBMS）で制御します。データとDBMS、およびそれらに関連するアプリケーションをまとめてデータベース・システムと呼びます。多くの場合は単にデータベースと呼んでいます。
> 
> 現在運用されている最も一般的なタイプのデータベースに格納されているデータは、処理とデータのクエリを効率化するために、一連のテーブルの行と列でモデル化されていることが普通です。このようにデータをモデル化すれば、アクセス、管理、変更、更新、制御、および整理が容易になります。ほとんどのデータベースでは、データの書き込みとクエリに構造化クエリ言語（SQL）を使用します。

エクセルやスプレッドシートを使ったことのある人ならイメージを抱きやすいと思います。正にそれがテーブルです。データベースには複数のテーブルを保存することが可能です。世の中のWebアプリケーションのデータや機密情報を永続化するために、このデータベースが利用されることが多いです。したがって、データベースの中身を不正に閲覧されることは脅威であると言えます。

SQLの記法はデータベースごとに異なります。大枠は同じですが、利用するDBに応じて見るドキュメントを変えましょう。今回利用するのは[SQLite](https://www.sqlite.org/docs.html)です。記法は[こちら](https://www.sqlite.org/lang.html)で確認してください。

以下のコマンドでSQLite3クライアントにて接続できるので、この状態でいくつかクエリを試してみてください。

```bash
$ sqlite3 ./app/step2.db
sqlite3> 
```

いくつかクエリの例を載せておきます。

1. usersテーブルから1件のレコードの情報を全て取得する

```sql
SELECT * FROM users LIMIT 1;
```

2. usersテーブルからid=1のユーザの名前を全て取得する

```sql
SELECT name FROM users WHERE id=1;
```

3. usersテーブルから山という文字を名前に含むレコードの情報を全て取得する

```sql
SELECT * FROM users WHERE name LIKE '%山%';
```

### 3. 実行されたSQLの理解

ここで、実行されているクエリについて考えてみます。

例えば、`中川` と入力して検索する時を考えてみましょう。まずは、実装されているコードを確認します([ref](./app/app.py#L36-L40))。

```python
# SQLite3のデータベースへの接続
c = sqlite3.connect(db_name)
# SQLクエリの構築
query = f"SELECT * FROM users WHERE name LIKE '%{name}%' AND is_admin=0"
# cursorの取得(一旦スルーしても良い)
# この辺りの説明が参考になるかも
# ref: https://wa3.i-3-i.info/word11582.html
cur = c.cursor()
# 構築したSQLクエリの実行
cur.execute(query)
# 実行されたSQL結果の取得
results = cur.fetchall()
```

今回は、`name`に検索文字列がインジェクト可能な仕様です。したがって、`中川`と入力して検索する場合、`SELECT * FROM users WHERE name LIKE '%中川%' AND is_admin=0` というSQL文が構築されます。

次はこのSQL文について考えてみます。

前から順に見ます。`SELECT * FROM users` で `users` テーブルから任意の(`*`)カラムのデータを取得するという意味になります。そして、`WHERE name LIKE '%中川%' AND is_admin=0`で、`name`カラムのデータに`中川`という文字を含み、かつ`is_admin`が`0`になる、という条件で絞り込んでいます。したがって、`users`テーブルの中にあり、`name`に`中川`という文字を含み、かつ`is_admin`が`0`である全ての全カラムのデータを取得するという意味になります。

### 4. 攻撃に必要なSQLの組み立て

実行されているクエリの組み立てられ方に注目してみましょう。`SELECT * FROM users WHERE name LIKE '%{NAME}%' AND is_admin=0` というSQL文において、`{NAME}`に任意の文字列をインジェクトされるイメージがつくでしょうか？
そして、この`{NAME}`に任意の文字列を入れられる時、想定外の挙動を起こすことができないでしょうか？

- 文字列だけでなく、記号を入れるとどうなるでしょうか？
- [SQLite3のシンタックスで利用できる記法](https://www.sqlite.org/lang.html)を参考に、何か悪さをできないでしょうか？

### 3. is_admin=1を無効に

実行されているクエリを操作しても、結局は `AND is_admin=0` による制限により、当初の目的であった `is_admin=1`の情報は得られません。では、この `AND is_admin` を無効化できる良い方法はないでしょうか？

この場合、[SQLiteのコメント記法](https://www.sqlite.org/lang_comment.html)を利用できます。SQL文は前から順番に評価されるため、インジェクトする部分にコメント記法を加えることで、後半の `AND is_admin` を無効化できます。

したがって、次のような文字列を`{NAME}`にインジェクトすれば良いことが良いでしょう。

```plaintext
' -- 
```

このクエリは見たことがあるかもしれません。実際に[http://localhost:31555](http://localhost:31555)というページにアクセスして確認しましょう。すると、次のように表示されることが分かります。

> 今実行されているクエリはSELECT * FROM users WHERE name LIKE '%' -- %' AND is_admin=0です。 

このクエリにおいて、まずコメントとして認識される部分を省くと次のように解釈できます。

```sql
SELECT * FROM users WHERE name LIKE '%' 
```

次に、WHEREの中身の条件を確認すると、`name LIKE '%'` になります。[SQLiteのドキュメント](https://www.sqlite.org/lang_expr.html#the_like_glob_regexp_match_and_extract_operators)によると、この `%` はワイルドカードと呼ばれ、任意の文字の繰り返しがマッチします。したがって、nameの任意の文字列に対応するため、usersテーブルの全てのレコードがマッチするので、それら全ての情報を得ることができます。

今回は `%` を利用しましたが、このように内部の実装がブラックボックスで見えていない場合、シングルクオートの後ろに `OR 1=1` をつける手法も一般的に知られています。これは、`1=1`という式の評価結果が必ず真になることを利用しています。ブール演算において真との論理和は必ず真なので、この方法は実質 `WHERE` の制限をないものとして解釈させることが可能です。

次は[step3 - sqlmapを触る](../step3/)です。本章で見つけたSQLインジェクションを脆弱性スキャナを利用して検出してみましょう！
